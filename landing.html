<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Harleen</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .floating-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .floating-heart {
            position: absolute;
            font-size: 2em;
            color: rgba(255, 107, 157, 0.6);
            animation: floatUp linear infinite;
            pointer-events: none;
        }

        .floating-compliment {
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2em;
            font-weight: 300;
            white-space: nowrap;
            animation: fadeInOut ease-in-out infinite;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100px) translateX(50px) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
            }
            20% {
                opacity: 0.8;
            }
            80% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
            }
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 60px 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: fadeIn 1s ease-in;
            position: relative;
            z-index: 10;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #f5576c;
            font-size: 3em;
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .message {
            color: #333;
            font-size: 1.3em;
            line-height: 1.8;
            margin-bottom: 40px;
            font-weight: 300;
        }

        .message .highlight {
            color: #f5576c;
            font-weight: 600;
        }

        .button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .button:active {
            transform: translateY(-1px);
        }

        .heart {
            display: inline-block;
            color: #ff6b9d;
            font-size: 1.5em;
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
        }
    </style>
</head>
<body>
    <audio id="backgroundMusic" autoplay loop>
        <source src="sonican-lo-fi-music-loop-sentimental-jazzy-love-473154.mp3" type="audio/mpeg">
    </audio>
    <div class="floating-background" id="floatingBackground"></div>
    <div class="container">
        <h1>Hiii Harleen <span class="heart">ðŸ’–</span></h1>
        <div class="message">
            Thank you for clicking on the link.<br>
            You make this world seem <span class="highlight">beautiful</span> and full of wonder. 
            Your presence brings light to every moment.
        </div>
        <button class="button" onclick="window.location.href='next.html'">
            Please Click Me to Go to the Next Page
        </button>
    </div>

    <script>
        const compliments = [
            "You're absolutely amazing",
            "Your smile lights up the room",
            "You're incredibly beautiful",
            "You have the kindest heart",
            "You're so special",
            "You make everything better",
            "You're perfect just the way you are",
            "You're absolutely stunning",
            "You bring joy wherever you go",
            "You're one of a kind",
            "You're simply wonderful",
            "You're amazing inside and out",
            "You're so lovely",
            "You're absolutely gorgeous",
            "You're truly special"
        ];

        const heartEmoji = 'ðŸ’–';

        const floatingBackground = document.getElementById('floatingBackground');
        const container = document.querySelector('.container');
        let complimentPositions = []; // Track active compliment positions
        let zoneOccupied = {
            topLeft: false,
            topRight: false,
            bottomLeft: false,
            bottomRight: false
        };

        // Create floating hearts
        function createFloatingHeart() {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.textContent = heartEmoji;
            heart.style.left = Math.random() * 100 + '%';
            heart.style.animationDuration = (Math.random() * 10 + 10) + 's';
            heart.style.animationDelay = Math.random() * 2 + 's';
            heart.style.fontSize = (Math.random() * 1.5 + 1.5) + 'em';
            floatingBackground.appendChild(heart);

            // Remove heart after animation
            setTimeout(() => {
                heart.remove();
            }, 25000);
        }

        // Get available zones (zones that don't have a compliment)
        function getAvailableZones() {
            const available = [];
            if (!zoneOccupied.topLeft) available.push('topLeft');
            if (!zoneOccupied.topRight) available.push('topRight');
            if (!zoneOccupied.bottomLeft) available.push('bottomLeft');
            if (!zoneOccupied.bottomRight) available.push('bottomRight');
            return available;
        }

        // Create floating compliments above or below the container
        function createFloatingCompliment() {
            const containerRect = container.getBoundingClientRect();
            const compliment = document.createElement('div');
            compliment.className = 'floating-compliment';
            compliment.textContent = compliments[Math.floor(Math.random() * compliments.length)];
            
            // Estimate text width (rough approximation)
            const estimatedTextWidth = compliment.textContent.length * 12; // ~12px per character
            const padding = 50; // Padding from screen edges
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Get available zones
            const availableZones = getAvailableZones();
            
            // If all zones are occupied, don't create a new compliment
            if (availableZones.length === 0) {
                return;
            }
            
            // Randomly select an available zone
            const selectedZone = availableZones[Math.floor(Math.random() * availableZones.length)];
            
            // Mark zone as occupied
            zoneOccupied[selectedZone] = true;
            
            // Calculate position based on zone
            const containerCenterX = containerRect.left + containerRect.width / 2;
            const containerCenterY = containerRect.top + containerRect.height / 2;
            let finalX, finalY;
            
            switch(selectedZone) {
                case 'topLeft':
                    // Above container, left side
                    finalX = Math.max(padding, containerCenterX - 250 - Math.random() * 100);
                    finalY = Math.max(padding, containerRect.top - 150 - Math.random() * 100);
                    break;
                case 'topRight':
                    // Above container, right side
                    finalX = Math.min(viewportWidth - estimatedTextWidth - padding, containerCenterX + 250 + Math.random() * 100);
                    finalY = Math.max(padding, containerRect.top - 150 - Math.random() * 100);
                    break;
                case 'bottomLeft':
                    // Below container, left side
                    finalX = Math.max(padding, containerCenterX - 250 - Math.random() * 100);
                    finalY = Math.min(viewportHeight - 100, containerRect.bottom + 150 + Math.random() * 100);
                    break;
                case 'bottomRight':
                    // Below container, right side
                    finalX = Math.min(viewportWidth - estimatedTextWidth - padding, containerCenterX + 250 + Math.random() * 100);
                    finalY = Math.min(viewportHeight - 100, containerRect.bottom + 150 + Math.random() * 100);
                    break;
            }
            
            compliment.style.left = finalX + 'px';
            compliment.style.top = finalY + 'px';
            // Vary animation duration more (8-18 seconds)
            const animationDuration = (Math.random() * 10 + 8);
            compliment.style.animationDuration = animationDuration + 's';
            // Vary delay more (0-4 seconds) so they appear at different times
            const animationDelay = Math.random() * 4;
            compliment.style.animationDelay = animationDelay + 's';
            
            // Store position with zone info
            complimentPositions.push({ 
                x: finalX, 
                y: finalY, 
                element: compliment,
                zone: selectedZone
            });
            
            floatingBackground.appendChild(compliment);

            // Remove compliment after animation completes (duration + delay + buffer)
            setTimeout(() => {
                compliment.remove();
                // Remove from tracking array
                const positionIndex = complimentPositions.findIndex(pos => pos.element === compliment);
                if (positionIndex !== -1) {
                    const zone = complimentPositions[positionIndex].zone;
                    zoneOccupied[zone] = false; // Free up the zone
                    complimentPositions.splice(positionIndex, 1);
                }
            }, (animationDuration + animationDelay) * 1000 + 1000); // Add 1 second buffer
        }

        // Create hearts periodically
        setInterval(createFloatingHeart, 1500);

        // Create compliments with variable timing
        function scheduleNextCompliment() {
            // Random delay between 4-10 seconds
            const delay = Math.random() * 6000 + 4000;
            setTimeout(() => {
                createFloatingCompliment();
                scheduleNextCompliment(); // Schedule the next one
            }, delay);
        }

        // Start scheduling compliments
        scheduleNextCompliment();

        // Create initial batch with staggered timing
        for (let i = 0; i < 5; i++) {
            setTimeout(createFloatingHeart, i * 300);
        }
        
        // Create initial compliments at different times (staggered)
        setTimeout(() => createFloatingCompliment(), 2000);
        setTimeout(() => createFloatingCompliment(), 5000);
        setTimeout(() => createFloatingCompliment(), 8000);
        setTimeout(() => createFloatingCompliment(), 12000);

        // Audio playback with seamless cross-page continuation
        const audio = document.getElementById('backgroundMusic');
        
        if (audio) {
            audio.volume = 0.5; // Set volume to 50%
            
            // Resume from stored time if available
            const storedTime = sessionStorage.getItem('audioTime');
            if (storedTime) {
                audio.currentTime = parseFloat(storedTime);
            }
            
            // Save current time periodically
            setInterval(() => {
                if (!audio.paused) {
                    sessionStorage.setItem('audioTime', audio.currentTime.toString());
                }
            }, 500);
            
            // Save time before page unload
            window.addEventListener('beforeunload', () => {
                sessionStorage.setItem('audioTime', audio.currentTime.toString());
            });
            
            // Save time on navigation
            document.addEventListener('click', (e) => {
                if (e.target.tagName === 'A' || e.target.closest('button[onclick*="location"]')) {
                    sessionStorage.setItem('audioTime', audio.currentTime.toString());
                }
            });
            
            audio.play().catch(e => {
                // Autoplay was prevented, start on user interaction
                document.addEventListener('click', () => {
                    audio.play().catch(() => {});
                }, { once: true });
            });
        }
    </script>
</body>
</html>
